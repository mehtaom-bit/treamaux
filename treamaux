#define leftsonicip
#define midsonicip
#define rightsonicip
#define leftsonicop
#define midsonicop
#define rightsonicop
#define motorrightfor
#define motorrightback
#define motorleftfor
#define motorleftback
#define NORTH 0
#define EAST  1
#define SOUTH 2
#define WEST  3

int x = 0, y = 0;   // Robot position
int marks[20][20] = {0};  // Grid for visited cells

int direction = NORTH;

float durationright, durationleft, durationmid, distanceright, distanceleft, distancemid;

void setup() {
  pinMode(leftsonicip, INPUT);
  pinMode(midsonicip, INPUT);
  pinMode(rightsonicip, INPUT);
  pinMode(leftsonicop, OUTPUT);
  pinMode(midsonicop, OUTPUT);
  pinMode(rightsonicop, OUTPUT);
  pinMode(motorrightfor, OUTPUT);
  pinMode(motorrightback, OUTPUT);
  pinMode(motorleftfor, OUTPUT);
  pinMode(motorleftback, OUTPUT);

}

float getdistanceleft(){
  	digitalWrite(leftsonicop, LOW);  
	delayMicroseconds(2);  
	digitalWrite(leftsonicop, HIGH);  
	delayMicroseconds(10);  
	digitalWrite(leftsonicop, LOW);  
  durationleft = pulseIn(leftsonicip, HIGH);  
  return (durationleft*.0343)/2;
}

float getdistanceright(){
  	digitalWrite(rightsonicop, LOW);  
	delayMicroseconds(2);  
	digitalWrite(rightsonicop, HIGH);  
	delayMicroseconds(10);  
	digitalWrite(rightsonicop, LOW);  
  durationright = pulseIn(rightsonicip, HIGH);  
  return (durationright*.0343)/2;
}

float getdistancemid(){
    	digitalWrite(midsonicop, LOW);    	
	delayMicroseconds(2);  
	digitalWrite(midsonicop, HIGH);  
	delayMicroseconds(10);  
	digitalWrite(midsonicop, LOW);  
  durationmid = pulseIn(midsonicip, HIGH);  
  return (durationmid*.0343)/2;
}

void moveforward(){
	analogWrite(motorleftfor, 200);
	analogWrite(motorleftback, 0);  
    	analogWrite(motorrightfor, 200);
    	analogWrite(motorrightback, 0);
	if (direction == NORTH) {
   		 y++;    // Move up
 	 } else if (direction == SOUTH) {
   		 y--;    // Move down
	 } else if (direction == EAST) {
  		  x++;    // Move right
 	 } else if (direction == WEST) {
		  x--;    // Move left
   	 }
	delay(300);
}

void movebackward(){
	analogWrite(motorleftfor, 0);
    	analogWrite(motorleftback, 200);
    	analogWrite(motorrightfor, 0);  
    	analogWrite(motorrightback, 200);
	if (direction == NORTH) {
    		y--;    // Move down
  	} else if (direction == SOUTH) {
    		y++;    // Move up
  	} else if (direction == EAST) {
    		x--;    // Move left
  	} else if (direction == WEST) {
    		x++;    // Move right
  	}
	delay(300);
}

void turnright(){
	analogWrite(motorleftfor, 200);
	analogWrite(motorleftback, 0);
	analogWrite(motorrightfor, 0);
	analogWrite(motorrightback, 200);

	direction = (direction + 1) % 4; 
	delay(300);
}

void turnleft(){
	analogWrite(motorleftfor, 0);
	analogWrite(motorleftback, 200);
	analogWrite(motorrightfor, 200);
	analogWrite(motorrightback, 0);

	direction = (direction + 3) % 4;
	delay(300);
}

bool isPathFront(){
	return distancemid() > 15;
}

bool isPathRight(){
	return distanceright() > 15;
}

bool isPathLeft(){
	return distanceleft() > 15;
}

void treamaux(){

  // Detect open paths
  bool front = isPathFront();
  bool left = isPathLeft();
  bool right = isPathRight();

  // Navigate based on available paths
  if (front && marks[x][y + 1] == 0) {
    moveforward();
} 
else if (left && marks[x - 1][y] == 0) {
    turnleft();
    moveforward();
} 
else if (right && marks[x + 1][y] == 0) {
    turnright();
    moveforward();
} 
else {
    // If no unvisited path → prefer cells marked 1
    if (front && marks[x][y + 1] == 1) {
        moveforward();
    } 
    else if (left && marks[x - 1][y] == 1) {
        turnleft();
        moveforward();
    } 
    else if (right && marks[x + 1][y] == 1) {
        turnright();
        moveforward();
    } 
    else {
        // Dead end → Backtrack
        movebackward();
    }
}

// Increment marking
marks[x][y]++;

}

void loop() {
  tremaux();
  delay(200);
}




	 	
  
  
